"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeatureFlags = void 0;
const ajv_1 = __importDefault(require("ajv"));
const fs = __importStar(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path = __importStar(require("path"));
const __1 = require("..");
const constants_1 = require("../constants");
const featureFlagFileProvider_1 = require("./featureFlagFileProvider");
const featureFlagEnvironmentProvider_1 = require("./featureFlagEnvironmentProvider");
class FeatureFlags {
    constructor(environmentProvider, projectPath) {
        this.environmentProvider = environmentProvider;
        this.projectPath = projectPath;
        this.registrations = new Map();
        this.effectiveFlags = {};
        this.newProjectDefaults = {};
        this.existingProjectDefaults = {};
        this.getValue = (flagName, type) => {
            if (!flagName) {
                throw new Error(`'flagName' argument is required`);
            }
            let value;
            const parts = flagName.toLowerCase().split('.');
            if (parts.length !== 2) {
                throw new Error(`Invalid flagName value: '${flagName}'`);
            }
            const sectionRegistration = this.registrations.get(parts[0]);
            if (!sectionRegistration) {
                throw new Error(`Section '${parts[0]}' is not registered in feature provider`);
            }
            const flagRegistrationEntry = sectionRegistration.find(flag => flag.name === parts[1]);
            if (!flagRegistrationEntry) {
                throw new Error(`Flag '${parts[1]}' within '${parts[0]}' is not registered in feature provider`);
            }
            if (flagRegistrationEntry.type !== type) {
                throw new Error(`'${flagName}' is a ${flagRegistrationEntry.type} type, not ${type}`);
            }
            if (this.effectiveFlags[parts[0]] && this.effectiveFlags[parts[0]][parts[1]]) {
                value = this.effectiveFlags[parts[0]][parts[1]];
            }
            if (!value) {
                value = flagRegistrationEntry.defaultValueForExistingProjects;
            }
            return value;
        };
        this.buildJSONSchemaFromRegistrations = () => {
            return [...this.registrations.entries()].reduce((s, r) => {
                var _a;
                const currentSection = ((_a = s.properties[r[0].toLowerCase()]) !== null && _a !== void 0 ? _a : {
                    type: 'object',
                    additionalProperties: false,
                });
                currentSection.properties = r[1].reduce((p, fr) => {
                    p[fr.name.toLowerCase()] = {
                        type: fr.type,
                        default: fr.defaultValueForNewProjects,
                    };
                    return p;
                }, {});
                s.properties[r[0].toLowerCase()] = currentSection;
                return s;
            }, {
                $schema: 'http://json-schema.org/draft-07/schema#',
                type: 'object',
                additionalProperties: false,
                properties: {},
            });
        };
        this.buildDefaultValues = () => {
            this.newProjectDefaults = [...this.registrations.entries()].reduce((result, r) => {
                const nest = r[1].reduce((p, fr) => {
                    p[fr.name] = fr.defaultValueForNewProjects;
                    return p;
                }, {});
                result[r[0]] = {
                    ...result[r[0]],
                    ...nest,
                };
                return result;
            }, {});
            this.existingProjectDefaults = [...this.registrations.entries()].reduce((result, r) => {
                const nest = r[1].reduce((p, fr) => {
                    p[fr.name] = fr.defaultValueForExistingProjects;
                    return p;
                }, {});
                result[r[0]] = {
                    ...result[r[0]],
                    ...nest,
                };
                return result;
            }, {});
        };
        this.validateFlags = (allFlags) => {
            const schema = this.buildJSONSchemaFromRegistrations();
            const ajv = new ajv_1.default();
            const schemaValidate = ajv.compile(schema);
            const validator = (target, flags) => {
                var _a;
                const valid = schemaValidate(flags);
                if (!valid && schemaValidate.errors) {
                    const jsonError = schemaValidate.errors[0];
                    const additionalProperty = (_a = jsonError === null || jsonError === void 0 ? void 0 : jsonError.params) === null || _a === void 0 ? void 0 : _a.additionalProperty;
                    const propertyMessage = additionalProperty ? `: '${additionalProperty}'` : '';
                    throw new __1.JSONValidationError(`${target}: ${ajv.errorsText(schemaValidate.errors)}${propertyMessage}`);
                }
            };
            const featureFlagsValidator = (type, features) => {
                validator(`${type} project`, features.project);
                for (let env of Object.keys(features.environments)) {
                    validator(`${type} environment (${env})`, features.environments[env]);
                }
            };
            for (let flagItem of allFlags) {
                featureFlagsValidator(flagItem.name, flagItem.flags);
            }
        };
        this.transformEnvFlags = (features) => {
            const convertValue = (section, flagName, value) => {
                const sectionRegistration = this.registrations.get(section);
                if (!sectionRegistration) {
                    throw new Error(`Section '${section}' is not registered in feature provider`);
                }
                const flagRegistrationEntry = sectionRegistration.find(flag => flag.name === flagName);
                if (!flagRegistrationEntry) {
                    throw new Error(`Flag '${flagName}' within '${section}' is not registered in feature provider`);
                }
                switch (flagRegistrationEntry.type) {
                    case 'boolean':
                        if (value === 'true') {
                            return true;
                        }
                        else if (value === 'false') {
                            return false;
                        }
                        else {
                            throw new Error(`Invalid boolean value: '${value}' for '${flagName}' in section '${section}'`);
                        }
                    case 'string':
                        return value.toString();
                    case 'number': {
                        const n = Number.parseInt(value, 10);
                        if (!Number.isNaN(n)) {
                            return n;
                        }
                        else {
                            throw new Error(`Invalid number value: '${value}' for '${flagName}' in section '${section}'`);
                        }
                    }
                    default:
                        throw new Error(`Invalid number value: ${value} for ${flagName}`);
                }
            };
            const mapFeatureFlagEntry = (input) => Object.keys(input).reduce((result, section) => {
                const sourceObject = input[section];
                result[section] = Object.keys(sourceObject).reduce((resultFlag, flagName) => {
                    const sourceValue = sourceObject[flagName];
                    resultFlag[flagName] = convertValue(section, flagName, sourceValue);
                    return resultFlag;
                }, {});
                return result;
            }, {});
            features.project = mapFeatureFlagEntry(features.project);
            for (let env of Object.keys(features.environments)) {
                features.environments[env] = mapFeatureFlagEntry(features.environments[env]);
            }
            return features;
        };
        this.registerFlag = (section, flags) => {
            var _a;
            if (!section) {
                throw new Error(`'section' argument is required`);
            }
            if (!flags) {
                throw new Error(`'flags' argument is required`);
            }
            const newFlags = (_a = this.registrations.get(section.toLowerCase())) !== null && _a !== void 0 ? _a : new Array();
            for (let flag of flags) {
                if (!flag.name || flag.name.trim().length === 0) {
                    throw new Error(`Flag does not have a name specified`);
                }
                if (newFlags.find(f => f.name === flag.name.toLowerCase())) {
                    throw new Error(`Flag with name: '${flag.name}' is already registered in section: '${section}'`);
                }
                flag.name = flag.name.toLowerCase();
                newFlags.push(flag);
            }
            this.registrations.set(section.toLowerCase(), newFlags);
        };
        this.registerFlags = () => {
            this.registerFlag('graphQLTransformer', [
                {
                    name: 'transformerVersion',
                    type: 'number',
                    defaultValueForExistingProjects: 4,
                    defaultValueForNewProjects: 5,
                },
            ]);
            this.registerFlag('keyTransformer', [
                {
                    name: 'defaultQuery',
                    type: 'boolean',
                    defaultValueForExistingProjects: false,
                    defaultValueForNewProjects: true,
                },
            ]);
        };
    }
}
exports.FeatureFlags = FeatureFlags;
FeatureFlags.initialize = async (environmentProvider, projectPath) => {
    var _a, _b;
    if (typeof jest === 'undefined' && FeatureFlags.instance) {
        throw new Error('FeatureFlags can only be initialzied once');
    }
    if (!environmentProvider) {
        throw new Error(`'environmentProvider' argument is required`);
    }
    if (!projectPath) {
        throw new Error(`'projectPath' argument is required`);
    }
    if (!(await fs.pathExists(projectPath))) {
        throw new Error(`Project path: '${projectPath}' does not exist.`);
    }
    const instance = new FeatureFlags(environmentProvider, projectPath);
    instance.registerFlags();
    const fileValueProvider = new featureFlagFileProvider_1.FeatureFlagFileProvider(environmentProvider, {
        projectPath,
    });
    const envValueProvider = new featureFlagEnvironmentProvider_1.FeatureFlagEnvironmentProvider({
        projectPath,
    });
    const fileFlags = await fileValueProvider.load();
    const envFlags = instance.transformEnvFlags(await envValueProvider.load());
    instance.validateFlags([
        {
            name: 'File',
            flags: fileFlags,
        },
        {
            name: 'Environment',
            flags: envFlags,
        },
    ]);
    instance.buildDefaultValues();
    instance.effectiveFlags = lodash_1.default.merge({}, fileFlags.project, (_a = fileFlags.environments[environmentProvider.getCurrentEnvName()]) !== null && _a !== void 0 ? _a : {}, envFlags.project, (_b = envFlags.environments[environmentProvider.getCurrentEnvName()]) !== null && _b !== void 0 ? _b : {});
    FeatureFlags.instance = instance;
};
FeatureFlags.ensureDefaultFeatureFlags = async (newProject) => {
    FeatureFlags.ensureInitialized();
    const configFileName = path.join(FeatureFlags.instance.projectPath, constants_1.amplifyConfigFileName);
    let config = await __1.JSONUtilities.readJson(configFileName, {
        throwIfNotExist: false,
        preserveComments: true,
    });
    if (!config || !config.features) {
        config = {
            ...(config !== null && config !== void 0 ? config : {}),
            features: newProject ? FeatureFlags.getNewProjectDefaults() : FeatureFlags.getExistingProjectDefaults(),
        };
        await __1.JSONUtilities.writeJson(configFileName, config, {
            keepComments: true,
        });
    }
};
FeatureFlags.getBoolean = (flagName) => {
    FeatureFlags.ensureInitialized();
    return FeatureFlags.instance.getValue(flagName, 'boolean');
};
FeatureFlags.getString = (flagName) => {
    FeatureFlags.ensureInitialized();
    return FeatureFlags.instance.getValue(flagName, 'string');
};
FeatureFlags.getNumber = (flagName) => {
    FeatureFlags.ensureInitialized();
    return FeatureFlags.instance.getValue(flagName, 'number');
};
FeatureFlags.getEffectiveFlags = () => {
    FeatureFlags.ensureInitialized();
    return FeatureFlags.instance.effectiveFlags;
};
FeatureFlags.getNewProjectDefaults = () => {
    FeatureFlags.ensureInitialized();
    return FeatureFlags.instance.newProjectDefaults;
};
FeatureFlags.getExistingProjectDefaults = () => {
    FeatureFlags.ensureInitialized();
    return FeatureFlags.instance.existingProjectDefaults;
};
FeatureFlags.removeFeatureFlagConfiguration = async (removeProjectConfiguration, envNames) => {
    FeatureFlags.ensureInitialized();
    if (!envNames) {
        throw new Error(`'envNames' argument is required`);
    }
    if (removeProjectConfiguration) {
        const configFileName = path.join(FeatureFlags.instance.projectPath, constants_1.amplifyConfigFileName);
        await fs.remove(configFileName);
    }
    for (let envName of envNames) {
        const configFileName = path.join(FeatureFlags.instance.projectPath, constants_1.amplifyConfigEnvFileNameTemplate(envName));
        await fs.remove(configFileName);
    }
};
FeatureFlags.isInitialized = () => {
    return FeatureFlags.instance !== undefined;
};
FeatureFlags.ensureInitialized = () => {
    if (!FeatureFlags.instance) {
        throw new Error('FeatureFlags is not initialized');
    }
};
//# sourceMappingURL=featureFlags.js.map